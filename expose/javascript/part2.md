1. At line 12, i will be printed out, which holds the iterations that occured in the loop. This occurs since i is defined with the keyword var, which has accesses throughout of the scope of the function, regardless of which block it is in. Since we pass an array of 3 elements, we will iterate through the loop 3 times, and thus i stores 3 once the loop is completed, and 3 is printed out
2. At line 13, the final discountedPrice value that is calculated in the loop will be printed out. This is again due to the scope of the discountedPrice variable, which is defined using the var keyword. Since we iterate through the loop 3 times, discountedPrice is reassigned 3 times, with the 3rd iteration result sticking in the variable which is printed. The value printed is 150, corresponding to the last value of the parameter array (300) and the operations perfomed on it.
3. The explanation to the answer is similar to that of question 2. At line 14, the final finalPrice value that is calculated in the loop will be printed out. The finalPrice variable is defined with the var keyword. In this function call, since we iterate the loop 3 times, finalPrice is reassigned 3 times after its initialization, where the 3rd iteration is what is stored in the variable after the loop is completed, which is the value that is printed. The value is 150, corresponding to the last value of the parameter array (300) and the operation of rounding the discounted price. 
4. The function returns an array that contains the modified prices that is passed in. Although not printed out in the terminal, the function returns the array which could be used out of the function if the result is declared into a variable.
5. At line 12, we will encounter an error since the variable i is defined with the keyword let. This means that i will only be accessible within the scope that it is defined. In this case, i is defined in the for-loop, the only place where it can be accessed. Line 12 calls i outside of the loop, where it can't exist, thus it throws an error indicating that i cannot be referenced due to it not having a definition outside of the loop scope.
6. The answer to the question is similar to question 5. At line 13, we will encounter an error since the variable discountedPrice is defined with the keyword let. Again, this means that discountedPrice can only be accessed withi the scope that it is defined in. In this case, discountedPrice is defined in the for-loop, the only place where it can be accessed. Line 13 calls the variable out of the loop, where it doesn't exist and thus it throws an error. discountedPrices cannot be referenced due to it not having a definition outside of the loop. 
7. Although finalPrice is defined with the keyword let, since it defined within the scope of the function, it can be accessed within the function as well as the for-loop in it. Therefore at Line 14, the programs prints out the final finalPrice value stored in it, which is evaluated using the for-loop. Since it iterates 3 times, finalPrice is reassigned 3 times within the loop, and the last iteration's result is stored in the variable, which can be referenced out of the loop due to its scope. The value printed is 150. 
8. The answer is similar to question 4, where the function returns an array that contains the modified prices that is passed in. Although not printed out in the terminal, the function returns the array which could be used out of the function if the result is declared into a variable. This variable is successfully able to hold and return the values calculated since the variable is defined with the keyword let, similar to how finalPrice is defined for question 7. This means the variable's scope is within the function, and this allows the result to be returned. 
9. The answer is similar to question 5. At line 11, an error is encountered since the variable i is defined with the keyword let. This means that i can only be accessed within the scope that it is defined. In this case, i is defined in the for-loop, the only place where it can be accessed. Line 11 calls i outside of the loop, where it can't exist thus throwing an error indicating that i cannot be referenced due to it not having a definition outside of the loop scope.
10. At Line 12, the function returns 3 for length. The variable length is defined with the keyword const, which indicates that once the variable is assigned with a value, it cannot be redeclared. In our function, we declare length to hold the length of the array passed in through the parameter. Throughout the function, we do not try to redeclare this variable, thus it never throws an error and goes to the print statement, where it prints the constant value for length in this pass of the function which is 3.
11. Just like questions 4 and 8, the function returns an array that contains the modified prices for the ones passed in. Although not printed out in the terminal, the function returns the array which could be used out of the function if the result is declared into a variable. This variable is successfully able to hold and return the values calculated since the variable is defined with the keyword const in the function scope, which allows the result to be returned. 
12. A) student.name;
    B) student['Grad Year'];
    C) student.greeting();
    D) student['Favorite Teacher'].name
    E) student.courseload[0]
13. A) 32 (as a string). The String literal for '3' is given, and when the    int 2 is passed in for addition, it instead converts 2 into a string and appends it to the end of the string, giving us '32'
    B) 1 (as an int). The String literal for '3' is given, however when int 2 is passed in for subtraction, the '3' is converted into an int and the subtraction operation is performed using 2, thus giving us 1
    C) 3 (as an int). In this case, null is converted into a number, i.e. 0, which is used for the operation with 3 to get 3
    D) 3null (as a string). In this case, null is converted into a string, i.e. 'null', which is concatenated to the string literal '3' to give '3null'
    E) 4 (as an int). True is typecasted into its numeric value, which is 1, and then is used with the int 3 for the operation to give us 4
    F) 0 (as an int). Both false and null are converted into their respective numerical values (0 and 0) before the addition occurs. Thus the result is 0
    G) 3undefined (as a string). We have already defined '3' as a string literal, and here undefined is also converted into a string to allow for concatenation, giving us '3undefined'
    H) NaN. Since we are dealing with a string literal as well as the undefined type which is casted into a number. This number is NaN, which when subtracted with the literal gives us NaN.
14. A) True. Here we compare the String literal '2' with the int 1. The string '2' in this case is converted into a int for the comparison, whose int value is 2 which is numerical greater than the int 1. Thus, '2' > 1 will return true
    B) False. Here we compare two strings with each other '2' and '12'. String comparisons occur where each literal in the string is compared with the other in order. In this case, the literal '2' is compared with the literal '1' of the string '12' first, and '2' is greater than '1', thus '2' < '12' gives us false. 
    C) True. The == operation compares if two elements are equal to each other, irregardless of their type (where a type conversion would be made). In this case, we compare the int 2 with the string literal '2'. Here '2' is converted into its int value which is 2, and it will be equal to the int passed in, which is also 2. Thus 2 == '2' gives us true.
    D) False. The === operation compares if two elements are equal to each other along with the consideration of their types. This means that ints will only equal the same int value, strings will only equal to the same string value, and so on. In this case, we compare the int 2 with the string literal '2'. Although when type casted they will be equal to each other, the === operation prevents it due to strict equality. Thus, the int 2 will not equal the string '2' and 2 === '2' will return false.
    E) False. Here, we compare the boolean true with the int 2. Since it is the == operation, the values will be type casted to be able to perform the equality check. Here, true is converted to its int value, 1, to perform the operation. 1 does not equal 2, and thus true == 2 returns false.
    F) True. The function Boolean(2) returns true. Since we use the === operation, which checks for types in consideration for equality, Boolean(2) result which is true will always equal to true. Thus true === Boolean(2) will return true
15. == and === both check for equality between the two arguments passed. However, == does a loose check, where it is able to check for equality between different data types by type casting them respectively in order to compare. So as the above questions, a comparision such as 2 == '2' would return true. ===, on the other hand, performs a strict check, where it determines equality not only on the value of the argument, but its data type as well. It does not perform a type conversion if two different data types are passed in. So in contrast, a comparision such as 2 === '2' would return false.
17. When we run the given function, we pass in the array [1,2,3] whose values are all doubled and returned using a callback function. The result of this function is [2,4,6]. The process of the code is simplified with the use of callback. When the function is called it is passed in with an int array as well as the function to be called back. In the function, we create a newArr which will store the result and run a forloop with the passed in parameters. Inside the loop, we perform the respective operation to the values using a callback to the doSomething function, and we go through the entire array by iterating through it. Once the loop is done, we return the newArr which stores the doubled values.
19. The output prints:
    1
    4
    3
    2
    Where first 3 lines are printed immediately, and the last line is printed after a delay.

